# Durak

Project Final Report
5/5/2021

## Introduction
In this project, I developed a program that plays Durak, a popular Russian card game, against a human opponent.  While the computer opponent implementation is extremely basic, the underlying foundation for Durak is designed in a way that would have made it easy to add more logic to the program’s card decisions if I had more time.  

## High Level Design
There are two groups of classes that are required for Durak.  First there are classes that are needed for any card game: Card, Deck, Hand, and Player.  Second, there are Durak specific classes that contain the implementation of the game and its rules.  In order to shorten the amount of code I would need to write and time to debug, I decided to try to implement the game first with two human opponents.  This approach would allow me to debug the gameplay logic first as well as implement a unique idea that would hopefully shorten the debugging time later on.  This idea was to use a vector of Player objects in the Game main loop and switch the indices every turn.  This way I could avoid hard coding which player attacks/defends at each instance and condenses the number of game states needed in that main loop.  Then, since I was already familiar with inheritance and polymorphism, I wanted to adapt Player into Computer and inherit all of the basic accessor/mutator methods and overload the Durak specific ones.  This would allow Computer to be substituted for a Player in the vector of Players without changing any of the later logic.  This approach was somewhat successful as I’ll detail in the remainder of this report.  

## Generic Card Game Foundation
Card is the foundation of this entire game and is a very straightforward class.  There are private variables for the card’s value, suit, and a boolean for whether or not it is a trump card.  For ease of comparison purposes, the special valued cards: Jack, Queen, King, and Ace have been assigned numerical values, 11, 12, 13, 14 respectively.  An important feature of Card is that it overloads <<, [], <, >, <=, >=, ==, and !=.  This enables me to access, compare, and print Card objects directly, vastly simplifying later code.  Trump cards are denoted in the << operator with an asterix.  

Deck is really just a vector of Cards that has methods for shuffle and draw (aka return and remove).  The “top” of the deck is the back of the vector, which allows draw() to utilize pop_back().  Draw(int index) is a method only used by shuffle() to ensure random index access at all times.  setTrump() differs slightly from the normal way Durak is played.  When this is called, the 0th index of the deck is used as the trump suit.  Normally the 13th card in the deck is used as the trump card after the deal, however since it is placed on the bottom anyway after the trump suit is revealed, I figured accessing the “bottom” card was a decent compromise.  

Hand is similar to deck as it is a vector of Cards, but has a few quality of life improvements.  When cards are added, the vector for the hand is sorted in ascending order.  This keeps the hand organized and puts trump cards at higher indices of the hand vector.  Unlike deck, where removing cards required you to remove from the end or by index, hand’s removeCard takes a Card variable to decide which one to remove.  This allowed me to access a card during the game and both push it to the playing field, and remove it from the deck in separate operations.  Removing and returning in the same method is tricky in C++ because vector’s erase() returns the pointer to the next element, rather than the removed element.  Hand’s << operator is slightly more involved as well because it prints all cards in the hand with the desired formatting.  

Player would normally be entirely a generic class, but this implementation has some overlap with Durak specific methods.  Player has a name and a hand object, plus accessors and mutators for those variables.  

## Durak Specific Classes/Methods
Methods for attack and defend are included in player to allow for the vector of Player object ideas to function. If I call v[0].attack() and v[1].defend() and then switch the objects referred to by v[0] and v[1], I can keep the same loop and same function calls for the second turn.  Attack and Defend are implemented similarly, they both take a vector called field which is a list of the cards in play, and check the current cards in play to determine which cards in their hand are “playable.”  Playable is a set of integers, where the integers refer to indexes of hand. This needs to be a set, because each card in the hand will be checked against each card in play and duplicates could arise.  Using a set saves some effort here because the duplicate indices cannot be added.  This was done to help the human player choose a legal move at each turn and also greatly simplified the logic required to be written for the computer.  Then both attack and defend prompt the player for a choice (as an index) for which element of playable they want to play.  Remember, the selected element of playable is actually the index of the desired card in hand, so once the selection is made, that card is removed from hand.  If cards were added to playable in the first step, and the player makes a legal choice of a card (error handling makes it impossible to move on without choosing a legal card actually) then attack and defend return true.  If no cards were added to playable (meaning no legal moves) then attack and defend return false.  

Game contains the remaining logic for the flow of the game.  The Game class implicitly creates the deck, so the constructors shuffle, set trump and create the players and their vector as needed for each type of game.  Lastly the constructor calls play() or playCPU() which begin the game.  Play utilizes a while loop that contains a switch and case block.  There are many different states in Durak and having a gigantic chain of if statements was not desirable.  I sectioned off the states of the game and set the value of state whenever I wanted to transition to a new state.  Cases 0 through 2 were left blank to implement a start up screen for Durak if I had the time.  The remaining cases function as follows:
  - Case 3: check if anyone is missing cards and if there are cards remaining in the deck, add cards until they have the minimum 6 cards.  
  - Case 4: prompt the attacking player to attack (or not attack and send cards to discard pile).  
  - Case 5: calls attack and uses the bool return value to decide whether to send cards to discard pile or move on to the opposing player’s defense state.  After this player plays a card, this state checks the win conditions to see if they are met.  
  - Case 6: prompt the defending player to defend (or not defend and pick up the cards)
  - Case 7: calls defend and uses the bool return value to decide whether to pick up the cards or to return to the attacking player’s attack state.  After this player plays a card, this state checks the win conditions to see if they are met. 
  - Case 8: moves cards to the discard pile, clears the cards in play, and swaps the players in the vector of players for the next iteration of the loop.  This returns to state 3 to replenish the player's hands.  
  - Default: this is where the winner is pronounced.  If the winning conditions are met after a card is played, state is set to -1 and we fall through to here, where the name of the player who won is printed out.  

One last unique thing about Game is the inclusion of promptContinue().  This text based version of the game has a lot of information to interpret and I found that it was a lot to take in if 5-6 lines appear at once.  This method is called frequently to pause the output unless the player presses enter.  

## Computer Opponent Design
While I had lofty goals to implement inheritance and polymorphism, both topics we did not cover, I ran out of time to actually make that happen.  (You can see my attempts commented out in Computer.h, .cpp and HumanPlayer.h, .cpp).  So I decided to create a second Game constructor to create a computer player, and a second playCPU() loop to handle the slightly different logic required since the computer does not need any text prompts to play.  playCPU() does not utilize the vector of players idea, but maintains the overall switch case structure.  Booleans for computer attack and computer defend are maintained at the top of the loop and are inverted each time we switch turns.  These booleans allow a short if statement in Cases 4 and 6 to circumvent the normal flow and send the program to Cases 9 or 10, where the computer’s version of attack and defend are called. 

Computer attack and defend follow the same structure of determining playable cards, but instead of prompting the computer for a choice of card, the computer always picks the first (0th) index of playable.  Attack and defend previously had enough error handling to prevent the player from making a non-legal move, the computer is also prevented from making a non-legal move.  Additionally, because hand and playable are both sorted in ascending order (hand by it’s add method and playable because it is a set) the computer will always pick non-trump cards to play if a non-trump card is considered a legal move.  This approach allows the computer to try to save trump cards to the very end to give it a shot at winning.  

## Known Issues/Bugs/Potential Improvements
There are a few issues with this implementation that I am aware of and arose due to lack of future time to work on this project.  First, player1 always goes first. Normally the player with the lowest trump card starts, and even a random start order might be better, but I did not get the chance to implement either.  Second, there are a few visual glitches involving promptContinue(). cin.ignore() is occasionally ignored, but I do not quite understand why.  Lastly an improvement that I had hoped to make but didn’t get around to was making a welcome screen.  Currently the game just jumps right in with zero explanation.  This additionally would include a choice between playing a human player and computer player as well.  

## Conclusion
Despite a few shortcomings and the time crunch, I am pleased with my implementation of Durak.  The game logic generally works without crashes and the foundation for generic card games is solid and the implementation of the Game logic with switch and case statements would allow for easy future improvements.  Additionally, my implementation goes slightly beyond the initial project proposal by allowing two human players to play against each other.  Lastly while the logic for the computer opponent is implemented at the most basic level, considerations made for human player error handling help the computer always make a legal move, even if it can’t make any real decisions.  
